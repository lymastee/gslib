#include <windows.h>
#include <gslib/xml.h>
#include <gslib/res.h>
#include <gslib/file.h>

using namespace gs;

#define indent4     _t("    ")
#define indent8     _t("        ")
#define indent12    _t("            ")

bool parse_path(const gchar* path, gs::string& dir, gs::string& file)
{
    const gchar* op = path;
    int len = strtool::length(path);
    path += len;
    for( ; path > op && path[-1] != _t('\\') && path[-1] != _t('/'); path --);
    if(path[-1] == _t('\\') || path[-1] == _t('/')) {
        dir.assign(op, (int)(path-op));
        file.assign(path, (int)((op+len)-path));
        return true;
    }
    return false;
}

void replace_postfix_with(const gchar* name, const gchar* pf, gs::string& str)
{
    assert(name && pf);
    int len = strtool::length(name);
    const gchar* s = name + len;
    for( ; s > name && s[0] != _t('.'); s --);
    if(s[0] == _t('.'))
        len = (int)(s-name);
    str.assign(name, len);
    str.push_back(_t('.'));
    str.append(pf);
}

void make_random_name(gs::string& str)
{
    GUID guid;
    CoCreateGuid(&guid);
    str.format(_t("res_%08x_%04x_%04x_%02x%02x_%02x%02x%02x%02x%02x%02x"), 
        (unsigned)guid.Data1, (unsigned)guid.Data2, (unsigned)guid.Data3,
        (unsigned)guid.Data4[0], (unsigned)guid.Data4[1], (unsigned)guid.Data4[2],
        (unsigned)guid.Data4[3], (unsigned)guid.Data4[4], (unsigned)guid.Data4[5],
        (unsigned)guid.Data4[6], (unsigned)guid.Data4[7]
        );
}

void parse_res_begin(file& f, const gchar* name)
{
    static const gchar* pstaticinfo = 
        _t("#include <gslib\\res.h>\n")
        _t("\n")
        _t("/*\n")
        _t(" * This file was generated by MRES tool, v1.0.\n")
        _t(" * DONOT modify this file, any changes been made through manual input would be lost.\n")
        _t(" */\n")
        _t("\n")
        _t("using namespace gs;\n")
        _t("\n");
    f.write(pstaticinfo);

    assert(name);
    string str;
    str.assign(_t("static struct "));
    str += name;
    str += _t(" {\n") indent4;
    str += name;
    str += _t("() {\n")
        indent8 _t("respack* pk = get_default_respack();\n")
        indent8 _t("assert(pk);\n");
    f.write(str);
}

void parse_res_end(file& f, const gchar* name)
{
    assert(name);
    string instname;
    instname.format(_t("m%s_inst"), name);
    string str;
    str.assign(indent4 _t("}\n} "));
    str += instname;
    str += _t(";\n");
    f.write(str);
}

bool parse_res_node(const xml_node* node, gs::string& buf, int index)
{
    assert(node);
    if(!node)
        return false;

    const string* vdir = node->get_attribute(_t("vdir"));
    const string* path = node->get_attribute(_t("path"));
    if(!vdir || !path)
        return false;

    file fsrc(path->c_str(), _t("rb"));
    if(!fsrc.is_valid()) {
        printf("source not existed: %ws.\n", path->c_str());
        return false;
    }

    string srn;
    srn.format(_t("r%d"), index);

    buf.assign(_t("/* "));
    buf += *vdir;
    buf += _t(" */\n")
        indent8 _t("static res ");
    buf += srn;
    buf += _t("[] = {\n");

    gs::byte srbuf[16];
    string numline;
    while(int s = fsrc.get(srbuf, sizeof(srbuf))) {
        if(s == 16) {
            numline.format(_t("0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, ")
                _t("0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, \n"),
                (unsigned)srbuf[0], (unsigned)srbuf[1], (unsigned)srbuf[2], (unsigned)srbuf[3],
                (unsigned)srbuf[4], (unsigned)srbuf[5], (unsigned)srbuf[6], (unsigned)srbuf[7],
                (unsigned)srbuf[8], (unsigned)srbuf[9], (unsigned)srbuf[10], (unsigned)srbuf[11],
                (unsigned)srbuf[12], (unsigned)srbuf[13], (unsigned)srbuf[14], (unsigned)srbuf[15]
                );
        }
        else {
            string cvt;
            numline.clear();
            for(int i = 0; i < s; i ++) {
                cvt.format(_t("0x%02x, "), (unsigned)srbuf[i]);
                numline += cvt;
            }
            numline += _t("\n");
        }
        buf += indent12;
        buf += numline;
    }
    buf.resize(buf.size()-3);

    buf += _t("\n") indent8 _t("};\n")
        indent8 _t("pk->reg(_t(\"");
    buf += *vdir;
    buf += _t("\"), ");
    buf += srn;
    buf += _t(", sizeof(");
    buf += srn;
    buf += _t("));\n");

    return true;
}

typedef vector<string> fwdirseq;

bool fwdirseq_getnotr(const gchar* dir, fwdirseq& fseq)
{
    assert(dir);
    for(const gchar* c = dir; ; ) {
        const gchar* seg = resvdir::get_next_node(c);
        gs::string s(c, (int)(seg-c));
        fseq.push_back(s);
        if(!seg[0] || seg[0] == _t('\r') || seg[0] == _t('\n'))
            break;
        c = seg + 1;
    }
    return true;
}

bool fwdirseq_get(const gchar* dir, fwdirseq& fseq)
{
    assert(dir);
    for(const gchar* c = dir; ; ) {
        const gchar* seg = resvdir::get_next_node(c);
        string s(c, (int)(seg-c));
        s == _t("..") ? fseq.pop_back() : fseq.push_back(s);
        if(!seg[0] || seg[0] == _t('\r') || seg[0] == _t('\n'))
            break;
        c = seg + 1;
    }
    return true;
}

bool fwdirseq_cstr(const fwdirseq& fseq, string& str, gchar slash = _t('\\'))
{
    for(int i = 0; i < (int)fseq.size(); i ++) {
        str.append(fseq.at(i));
        str.push_back(slash);
    }
    return true;
}

bool fwdirseq_equal(const fwdirseq& fseq1, const fwdirseq& fseq2)
{
    if(fseq1.size() != fseq2.size())
        return false;
    for(int i = 0; i < (int)fseq1.size(); i ++) {
        if(fseq1.at(i).compare_cl(fseq2.at(i).c_str()) != 0)
            return false;
    }
    return true;
}

bool fwdirseq_equal(const fwdirseq& fseq1, const fwdirseq& fseq2, int len)
{
    if((int)fseq1.size() < len || (int)fseq2.size() < len)
        return false;
    for(int i = 0; i < len; i ++) {
        if(fseq1.at(i).compare_cl(fseq2.at(i).c_str()) != 0)
            return false;
    }
    return true;
}

bool fwdirseq_diff(const fwdirseq& fseq1, const fwdirseq& fseq2, fwdirseq& fdiff)
{
    if(fseq1.size() < fseq2.size()) {
        if(!fwdirseq_equal(fseq1, fseq2, (int)fseq1.size()))
            return false;
        for(int i = (int)fseq1.size(); i < (int)fseq2.size(); i ++)
            fdiff.push_back(fseq2.at(i));
        return true;
    }
    else if(fseq1.size() > fseq2.size()) {
        if(!fwdirseq_equal(fseq1, fseq2, (int)fseq2.size()))
            return false;
        for(int i = (int)fseq2.size(); i < (int)fseq1.size(); i ++)
            fdiff.push_back(_t(".."));
        return true;
    }
    return fwdirseq_equal(fseq1, fseq2);
}

bool is_absdir(const gchar* dir)
{
    return dir && dir[0] && (dir[1] == _t(':'));
}

const gchar* select_include_path(gchar buf[])
{
    const gchar* src = buf;
    for( ; src[0] == _t(' ') || src[0] == _t('\t'); src ++) {
        if(!src[0] || src[0] == _t('\r') || src[0] == _t('\n'))
            return 0;
    }
    if(strtool::compare(src, _t("#include"), _cststrlen(_t("#include"))) != 0)
        return 0;
    src += _cststrlen(_t("#include"));
    if(!(src = strtool::find(src, _t("\""))))
        return 0;
    gchar* srp = (gchar*)strtool::find(++src, _t("\""));
    if(!srp)
        return 0;
    srp[0] = 0;
    return src;
}

int wmain(int argc, gchar* argv[])
{
    if(argc < 2) {
        /* help info. */
        printf(
            "MRES tool, v1.0\n"
            "This tool would help you embed your resource into your EXE/DLL files.\n"
            "The procedure was:\n"
            "1.generate a CPP file which contained your resources in forms like static data.\n"
            "2.include this CPP file into another compilable file like CPP/C/CC file, which was assigned by "
            "the input MRX file. \n"
            "3.you can access your resources in your program via the virtual dir like \":/path1/path2/res1.sh\" \n"
            "Notes:\n"
            "1.the MRX file was actually a XML file.\n"
            "2.\"mres:currdir\": predicts the current dir, absolutely or relatively to the MRX file dir.\n"
            "3.\"mres:target\": predicts the target file, and you need to make sure it could be compiled.\n"
            "4.\"res\": as it shows..\n"
            );
        system("pause");
        return 0;
    }

    CoInitialize(0);

    const gchar* path = argv[1];
    assert(path);
    string dir, fn;
    if(!parse_path(path, dir, fn)) {
        printf("invalid path: can't get directory from the path.\n");
        system("pause");
        return 0;
    }

    xmltree xml;
    if(!xml.load(path)) {
        printf("open file: \"%ws\" failed, file not exist or bad format.\n", path);
        system("pause");
        return 0;
    }

    xmltree::iterator i = xml.get_root();
    static_cast_as(xml_element*, elem, i.get_ptr());
    if(!i.is_valid() || elem->key != _t("mres")) {
        printf("bad format, root node \"%ws\" != \"mres\"\n", elem->key.c_str());
        system("pause");
        return 0;
    }

    SetCurrentDirectory(dir.c_str());
    if(string* cd = i->get_attribute(_t("currdir")))
        SetCurrentDirectory(cd->c_str());

    string* target = i->get_attribute(_t("target"));
    if(!target) {
        printf("bad format, necessary attribute \"target\" missed.\n");
        system("pause");
        return 0;
    }

    string cppfile;
    replace_postfix_with(fn.c_str(), _t("cpp"), cppfile);
    file fcpp(cppfile.c_str(), _t("w"));
    if(!fcpp.is_valid()) {
        printf("open/create file \"%ws\" failed.\n", cppfile.c_str());
        system("pause");
        return 0;
    }

    string phname;
    make_random_name(phname);
    parse_res_begin(fcpp, phname.c_str());

    string buf;
    int index = 0;
    for(i.to_child(); i.is_valid(); i.to_next(), index ++) {
        if(!parse_res_node(i.get_ptr(), buf, index)) {
            printf("parse res node failed.\n");
            system("pause");
            return 0;
        }
        fcpp.write(buf);
    }

    parse_res_end(fcpp, phname.c_str());

    file apto(target->c_str(), _t("a+"));
    if(!apto.is_valid()) {
        printf("target files doesn't existed, appending failed.\n");
        system("pause");
        return 0;
    }
    apto.rewind();

    gchar abscurdir[MAX_PATH];
    GetCurrentDirectory(sizeof(abscurdir), abscurdir);
    fwdirseq cdseq;
    fwdirseq_get(abscurdir, cdseq);

    assert(!is_absdir(target->c_str()));
    fwdirseq tarseq = cdseq;
    fwdirseq_get(target->c_str(), tarseq);
    tarseq.pop_back();

    fwdirseq fdiff;
    fwdirseq_diff(tarseq, cdseq, fdiff);
    fdiff.push_back(cppfile);

    /* max sentence */
    gchar rbuf[256] = _t("");
    while(apto.read(rbuf, _countof(rbuf))) {
        const gchar* incp = select_include_path(rbuf);
        if(!incp)
            continue;
        fwdirseq cmpdir;
        fwdirseq_getnotr(incp, cmpdir);
        if(fwdirseq_equal(fdiff, cmpdir))
            return 0;
    }

    string apts;
    fwdirseq_cstr(fdiff, apts);
    apts.pop_back();
    string aptsbuf;
    aptsbuf.format(_t("#include \"%s\""), apts.c_str());
    apto.write(aptsbuf);

    return 0;
}
