/*
 * Copyright (c) 2016-2020 lymastee, All rights reserved.
 * Contact: lymastee@hotmail.com
 *
 * This file is part of the gslib project.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <gslib/error.h>
#include <gslib/string.h>
#include <gslib/uuid.h>
#include "uic.h"

using namespace gs;

namespace ui_editor {

#define uic_indent              _t("    ")
#define uic_default_cls_name    _t("my_ui_class")
#define uic_blanks              _t(" \t\v\r\n\f")

static void uic_write_reminder_comment(string& output)
{
    output.append(
        _t("/*\n")
           " * This file was generated by UIC tool version 1.0 automatically.\n"
           " * Please DONOT modify this file, any changes made to this file manually will be lost.\n"
           " * You should modify the correspond .ui file instead.\n"
           " */\n\n"
        );
}

static void uic_write_header_guard_begin(string& output)
{
    output.append(_t("#pragma once\n\n"));
    uuid uid(uuid_ver_default);
    string suid;
    uid.to_string(suid);
    for(size_t p = 0, f; (f = suid.find(_t('-'), p)) != string::npos; p = f + 1)
        suid.at(f) = _t('_');
    string hgstr(_t("ui_"));
    hgstr.append(suid);
    hgstr.append(_t("_h\n"));
    output.append(_t("#ifndef "));
    output.append(hgstr);
    output.append(_t("#define "));
    output.append(hgstr);
    output.push_back(_t('\n'));
}

static void uic_write_header_guard_end(string& output)
{
    output.append(_t("#endif\n"));
}

static void uic_write_includes(string& output, const ui_includes& includes)
{
    if(includes.empty())
        return;
    for(const auto& record : includes) {
        output.append(_t("#include <"));
        output.append(record);
        output.append(_t(">\n"));
    }
    output.push_back(_t('\n'));
}

static void uic_write_macros(string& output, const ui_macros& macros)
{
    if(macros.empty())
        return;
    for(const auto& record : macros) {
        assert(!record.name.empty());
        if(record.definition.empty()) {
            output.append(_t("#define "));
            output.append(record.name);
            output.push_back(_t('\n'));
        }
        else {
            output.append(_t("#define "));
            output.append(record.name);
            output.push_back(_t('\t'));
            output.append(record.definition);      /* no folding */
            output.push_back(_t('\n'));
        }
    }
    output.push_back(_t('\n'));
}

static void uic_write_injection_proc(string& output, const string& injection)
{
    if(injection.empty())
        return;
    output.append(injection);
    output.append(_t("\n\n"));
}

static void uic_write_line(string& output, const string& line, int indent)
{
    assert(indent >= 0 && indent < 100);
    for(int i = 0; i < indent; i ++)
        output.append(uic_indent);
    output.append(line);
    output.push_back(_t('\n'));        /* EOL */
}

class uic_compiler
{
public:
    struct ui_member_record
    {
        const ui_node*      parent;
        const ui_node*      node;

    public:
        ui_member_record() { parent = node = nullptr; }
        ui_member_record(const ui_node* p, const ui_node* n): parent(p), node(n) {}
    };
    typedef unordered_map<string, ui_member_record> ui_member_map;

public:
    uic_compiler(string& output, const ui_editor_context& ctx):
        _ctx(ctx), _output(output)
    {
        write_class_begin();
    }
    bool parse(const ui_tree& uitree, const ui_tree::const_iterator& i)
    {
        assert(i);
        uic_write_line(_init_entry, _t("void initalize(gs::ariel::wsys_manager* wsys, gs::ariel::widget* parent)"), 1);
        uic_write_line(_init_entry, _t("{"), 1);
        bool result = parse_ui_member(uitree, i, 2);
        uic_write_line(_init_entry, _t("}"), 1);
        return result;
    }
    void finish()
    {
        uic_write_line(_output, _t("public:"), 0);
        write_constructor(1);
        _output.append(_init_entry);
        _output.push_back(_t('\n'));
        uic_write_line(_output, _t("protected:"), 0);
        write_member_declarations(1);
        _output.push_back(_t('\n'));
        uic_write_line(_output, _t("protected:"), 0);
        write_member_initializers(1);
        write_class_end();
    }

protected:
    const ui_editor_context& _ctx;
    string&                 _output;
    ui_member_map           _member_map;
    string                  _init_entry;

protected:
    bool register_ui_member(const string& name, const ui_node* parent, const ui_node* node)
    {
        assert(node);
        auto f = _member_map.try_emplace(name, ui_member_record(parent, node));
        return f.second;
    }
    void write_class_begin()
    {
        const string& class_name = _ctx.const_src_entry().get_export();
        string class_title;
        class_title.format(_t("class %s"), class_name.empty() ? uic_default_cls_name : class_name.c_str());
        uic_write_line(_output, class_title, 0);
        _output.append(_t("{\n"));
    }
    void write_class_end()
    {
        _output.append(_t("};\n\n"));
    }
    const string& generate_initializer_name(string& name, const ui_node* node)
    {
        assert(node);
        if(node->variable.front() == _t('_') || isupper(node->variable.front()))
            name.format(_t("init%s"), node->variable.c_str());
        else
            name.format(_t("init_%s"), node->variable.c_str());
        return name;
    }
    const string& generate_initializer(string& fn_init, const ui_node* parent, const ui_node* node, int indent)
    {
        assert(node);
        auto init_proc_node = node->proc_map.find(_t("initialize"));
        string initr_name;
        generate_initializer_name(initr_name, node);
        string arg1(_t("wsys")), arg2(_t("parent"));
        if(init_proc_node != node->proc_map.end() && !init_proc_node->second.args.empty()) {
            /* replacement for arg table, format: arg1,arg2 */
            const string& override_args = init_proc_node->second.args;
            auto p = override_args.find(_t(','));
            if(p != string::npos) {
                if(p != 0)
                    arg1.assign(override_args, 0, p);
                if(++ p != override_args.size())
                    arg2.assign(override_args, p, override_args.size() - p);
            }
            else {
                arg1 = override_args;
            }
        }
        string initr_title;
        if(!parent) {
            initr_title.format(_t("%s* %s(gs::ariel::wsys_manager* %s, gs::ariel::widget* %s)"),
                node->type.c_str(), initr_name.c_str(), arg1.c_str(), arg2.c_str()
                );
        }
        else {
            initr_title.format(_t("%s* %s(gs::ariel::wsys_manager* %s, %s* %s)"),
                node->type.c_str(), initr_name.c_str(), arg1.c_str(), parent->type.c_str(), arg2.c_str()
            );
        }
        uic_write_line(fn_init, initr_title, indent);
        uic_write_line(fn_init, _t("{"), indent);
        if(init_proc_node != node->proc_map.end() && !init_proc_node->second.injection.empty()) {
            const string& injection = init_proc_node->second.injection;
            for(int p = 0; p < injection.size();) {
                int f = (int)injection.find_first_of(_t("\r\n"), p);
                if(f == string::npos)
                    f = injection.size();
                int trim_off = (int)injection.find_first_not_of(uic_blanks, p);
                if(trim_off == string::npos) {
                    p = f + 1;
                    continue;
                }
                p = trim_off;
                /* deal with indent */
                int extra_indent = 0;
                if(injection.at(p) == _t('@')) {
                    int readn = 0;
                    if(gs::strtool::sscanf(&injection.at(p), _t("@indent:%d;"), &readn) == 1) {
                        extra_indent = readn;
                        int jump_off = (int)injection.find_first_of(_t(';'), p);
                        assert(jump_off != string::npos);
                        p = jump_off + 1;
                    }
                }
                string inject_line;
                inject_line.assign(injection, p, f - p);
                uic_write_line(fn_init, inject_line, indent + 1 + extra_indent);
                p = f + 1;
            }
        }
        uic_write_line(fn_init, _t("}"), indent);
        return fn_init;
    }
    bool parse_ui_member(const ui_tree& uitree, const ui_tree::const_iterator& i, int indent)
    {
        assert(i);
        if(!register_ui_member(i->variable, i.parent() ? i.parent().get_ptr() : nullptr, i.get_ptr()))
            return false;
        string init_cmd;
        string parent_var(_cststr(_t("parent")));
        if(i.parent())
            parent_var = i.parent()->variable;
        if(i->is_instance) {
            init_cmd.format(_t("%s = wsys->add_widget<%s>(%s, _t(\"%s\"), gs::rect(%d, %d, %d, %d), gs::ariel::sm_hitable | gs::ariel::sm_visible);"),
                i->variable.c_str(), i->type.c_str(), parent_var.c_str(), i->name.c_str(), i->position.left, i->position.top, i->position.width(), i->position.height()
                );
        }
        else {
            string initr;
            generate_initializer_name(initr, i.get_ptr());
            init_cmd.format(_t("%s = %s(wsys, %s);"), i->variable.c_str(), initr.c_str(), parent_var.c_str());
        }
        uic_write_line(_init_entry, init_cmd, indent);
        bool result = true;
        for(auto c = i.child(); c; c = c.next())
            result &= parse_ui_member(uitree, c, indent);
        return result;
    }
    void write_constructor(int indent)
    {
        const string& class_name = _ctx.const_src_entry().get_export();
        string ctor_title;
        ctor_title.format(_t("%s()"), class_name.empty() ? uic_default_cls_name : class_name.c_str());
        uic_write_line(_output, ctor_title, indent);
        uic_write_line(_output, _t("{"), indent);
        for(auto& m : _member_map) {
            string cmd;
            cmd.format(_t("%s = nullptr;"), m.first.c_str());
            uic_write_line(_output, cmd, indent + 1);
        }
        uic_write_line(_output, _t("}"), indent);
    }
    void write_member_declarations(int indent)
    {
        for(auto& m : _member_map) {
            string decl;
            const ui_node* n = m.second.node;
            assert(n);
            decl.format(_t("%s* %s;"), n->type.c_str(), n->variable.c_str());
            uic_write_line(_output, decl, indent);
        }
    }
    void write_member_initializers(int indent)
    {
        for(auto& m : _member_map) {
            if(!m.second.node->is_instance)
                generate_initializer(_output, m.second.parent, m.second.node, indent);
        }
    }
};

static void uic_setup_variable_names(ui_editor_context& ctx, ui_tree& uitree)
{
    uitree.for_each([&ctx](ui_node* node) {
        assert(node && !node->type.empty());
        if(node->variable.empty())
            ctx.acquire_variable_name(node->variable, node->type);
    });
}

bool ui_compile(string& output, const ui_editor_context& ctx, const ui_tree& uitree)
{
    bool result = true;
    uic_write_reminder_comment(output);
    uic_write_header_guard_begin(output);
    uic_write_includes(output, ctx.const_src_entry().get_includes());
    uic_write_macros(output, ctx.const_src_entry().get_macros());
    uic_write_injection_proc(output, ctx.const_src_entry().get_preproc());
    uic_setup_variable_names(const_cast<ui_editor_context&>(ctx), const_cast<ui_tree&>(uitree));
    uic_compiler uicc(output, ctx);
    result = uicc.parse(uitree, uitree.get_root());
    uicc.finish();
    uic_write_injection_proc(output, ctx.const_src_entry().get_postproc());
    uic_write_header_guard_end(output);
    return true;
}

};
